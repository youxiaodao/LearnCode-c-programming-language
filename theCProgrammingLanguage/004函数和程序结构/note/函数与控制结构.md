
# 4.1函数的基本知识
1. 我们将一个大的功能的每个小功能设计成一个独立的函数
2. 分别处理3个小的部分比处理一个大的整体更容易
3. 因为这样可以把不想关的细节隐藏在函数中,从而减少了不必要的相互影响的机会
4. 并且, 这些函数也可以在其他函数中使用
5. 标准库函数strstr的功能类似于strindex函数,该函数返回指定字符串的指针
6. 在不同的系统中, 保存在多个源文件中的c语言程序的编译与加载机制是不同的
    1. UNIX 

# 4.2 返回非整形值得函数
1. double atof(char s[])
2. 调用函数必须知道函数得返回值类型,
3. 如果函数是单独编译的, 不匹配得错误就无法检测出来
4. 如果没有函数原型, 则函数将在第一次出现的额表达式中被隐式声明
5. 参数声明

# 4.3 外部变量
1. C语言不允许在一个函数中定义其它函数
2. 使用外部变量, 要比使用一个很长得参数列表更方便有效, 但是, 这样做必须非常谨慎, 因为这样方式可能对程序结构产生不良得影响, 而且可能会导致程序总各个函数之间具有太多得数据联系
3. 与内部变量相比, 他们具有更大得作用域, 和更长的生存期
4. 逆波兰表示法
    ```
    (1 - 2) * (4 + 5)
    ====>
    1 2 - 4 5 + * 
    ```
5. 计算机程序
    1. 重要的问题: 把栈放在哪里? 
        - main函数不需要了解控制栈的变量信息
        - 因此, 可以把栈及相关信息放在外部变量中, 并只提供push pop 函数访问
6. + 和 * 两个运算符满足交换律, 因此, 操作数的弹出次序无关紧要。但是, - 与 / 的左右必须区分
    ```c
    push(pop() - pop()); // 错
    ```
7. 程序中经常出现这样的情况, 程序不能确定它已经读入的输入是否足够, 除非超前多读入一些
    - 编写一对互响写作的函数来比较方便地模拟反取字符操作

# 4.4 作用域规则
1. 问题
    - 如何进行声明, 才能确保变量在编译时被正确声明
    - 如何安排声明地位置, 才能确保程序在加载时各部分能正确连接?
    - 如何组织程序中地声明, 才能确保只有一份副本
    - 如何初始化外部变量
2. 函数开头声明地自动变量的作用域
3. 外部变量或者函数的作用域
4. 外部变量的声明与定义区分开来，很重要
    - 变量的声明, 用于说明变量的属性
    - 变量的定义, 还将引起存储器的分配
5. extern 
    - 外部变量的定义中, 必须指定数组的长度, 但extern声明则不一定要指定数组的长度
    - 外部变量的初始化只能出现在定义中

# 4.5 头文件
> 将上面的程序文件拆分
1. 一方面, 我们期望每个文件只能访问它完成任务所需的信息
2. 另一方面, 现实中维护较多的头文件比较困难
3. 我们的结论
    - 中等规模的程序, 只好用一个头文件存放程序中各部分共享的对象
    - 较大的程序需要使用更多的头文件, 我们要精心的组织它们

# 4.6 静态变量
1. static声明 , 将作用域限定在被编译文件的剩余部分中
2. static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量

# 4.7 寄存器变量
1. register
2. 过量的寄存器变量并没有什么害处, 知识因为编译器可以忽略过量的或不支持的寄存器变量声明

# 4.8 程序块结构
1. 花括号

# 4.9 初始化
1. 在不进行显示声明的情况下, 外部变量和静态变量都被初始化为0, 而自动变量和寄存器变量的初始值则没有意义
2. 数组的初始化实在声明的后面紧跟一个初始化一个表达式列表
    - 当省略数组的长度, 编译器就把花括号中初始化表达式的个数作为数组的长度
    ```c
    int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
    ```
3. 字符组的初始化比较特殊
    ```c
    char pattern[] = "ould";
    // 等价于
    char pattern[] = { 'o', 'u' ... }
    ```
# 4.10 递归
1. 数字是以反序生成的
    - 数据对其的段模式
    - 与处理器 相关
2. 标准库提供 qsort函数, 它可用于对任何类型的对象排序
3. 递归并不节省存储器的开销, 需要在某个地方维护一个存储处理器值得栈
4. 执行速度并不快, 但更容易编写和理解

# 4.11 C预处理器
1. #include
2. #define

# 4.11.1 文件包含
```c
#include "文件名"
#include <文件名>
```
1. 如果文件名用引号引起来, 则源文件所在位置查找该文件
2. 如果文件名用尖括号括起来, 则根据相应得规则查找文件, 这个规则同具体得实现有关

# 4.11.2 宏替换
```c
#define 名字 替换文本
#define forever for (;;)  // 无限循环
#defing max(A, B) ((A) > (B) ? (A) : (B))
x = max(p+q, r+s)
```
1. 也可以把一个较长的宏定义分成若干行, 这时需要在待续的行末尾加上一的反斜杠 \
2. 缺陷
    - 使用圆括号保证计算次序的正确性
3. 通过 #undef指令取消名字的宏定义
4. 形式参数不能用带引号的字符串提供, 但是, 如果在替换文本中参数名以#作为前缀, 则结果将被扩展为由实际参数替换该参数的带引号的字符串。
5. ## 很难掌握,参阅附录A

# 条件包含
1. 可以使用条件语句对预处理本身进行控制
```c
#if !defined(HDR)
#define HDR
/* hdr.h 文件的内容放在这里 */
#endif
```
2. defined(名字) 该表达式遵循一下规则, 当名字已经定义时, 其值为1, 否则, 其值为0
3. 以上类似的方法也可以用来避免多西重复包含同一文件
4. #ifdef 和#ifndef  改写上面的例子
```c
#ifndef HDR
#define HDR

....
#endif
```
