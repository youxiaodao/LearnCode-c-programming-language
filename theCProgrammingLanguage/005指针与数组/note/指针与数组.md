1. ANSI使用类型void*(指向void的指针) 代替char*作为通用指针的类型

## 5.1指针与地址
1. 内存是如何组织的?
   1. 连续编号的存储单元
   2. 一个字节-一个char类型的数据
   3. 连个相邻的字节存储一个short(短整型)的类型
   4. 4个相邻的字节-一个long(长整型)
2. & 一元运算符 --- 用于取一个对象的地址
   ```c
      p =  &c
   ```
3. p为指向c的指针
4. &只能作用与内存中的对象，即变量和数组元素，不能作用于表达式，常量，或者register类型的变量
5. *一元运算符 --- 是间接寻址或者间接引用运算符
   1. 定义指针类型 int *ip;int a = 1;ip = &a; *ip = 0; 相当于a = 0
6. 每个指针都必须指向某种特定的数据类型
   1. 一个例外情况是指向void类型的指针可以存放执行任何类型的指针
   2. 但它不能间接引用其自身
7. (*ip)++ 括号是必须的
   1. 否则, 该表达式将对ip进行加1运算而不是对ip指向的对象进行加1
   2. 类似于* ++ 遵循从右到左的结合顺序

## 5.2指针与函数参数
1. c语言是传值的方式将参数值传递给被调用函数的
   1. 因此, 被调函数不能直接修改主调函数的值
      ```c
      swap(x,y);
      swap(&x, &b);

      void swap(int *px, int *py) {
         int temp;
         temp = *px;
         *px = *py;
         *py = temp;
      }
      ```
   2. 指针参数使得被调用函数能够访问和修改主调函数中对象的值
2. 

## 5.3指针与数组
1. 通过数组下标所能完成的任何操作都可以通过指针来实现
   1. 一般来说, 用指针编写的程序比数组下标编写的程序执行速度快, 但另一方面, 用指针实现的程序理解起来稍微困难一些
   ```c
   int a[10];
   int *pa;
   pa = &a[0];
   // 执行后, pa 和a 具有相同的值,
   // 因为数组名所代表的就是该数组最开始的一个元素的地址
   // 所以也可以写成下面的形式
   pa = a;
   // 对数组元素 a[i] 的引用也可以写成
   *(a + i);
   // &a[i] 和 a + i 的的含义也是相同的
   // 因此 pa[i] 与 *(pa + i) 是等价的
   // 简而言之, 一个数组的下标实现的表达式可等价地通过指针和偏移量实现
   int x;   // 是否可以
   x = *pa;  // 把数组a[0]中的内容复制到x中
   // pa + 1 将指向下一个元素 pa - i 将指向pa所指向数组元素之前的第i个元素
   *(pa + 1); // 指向 a[1]
   ```
2. 必须记住, 数组名和指针之间有一个不同之处, 指针式一个变量
   1. 因此 pa=a 和 pa++ 都是合法地
   2. 但数组名不是变量 类似a = pa 和 a ++ 是不合法地
3. 当把数组名传递给一个函数时, 实际上传递地是该数组第一个元素地地址, 在被调用函数中,该参数是一个局部变量, 因此，数组名必须是一个指针，也就是一个存储地址值地变量。
   ```c
   int strlen(char *s) {
      int n;
      for(n = 0; *s != '\0; s++){
         n++;
      }
      return n;
   }

   strlen("hello, world"); //字符串常量
   strlen(array); // 字符数组
   strlen(ptr);   // 指向char类型对象地指针
   ```
4. 在函数定义中.形式参数 char [], 和 char *s是等价地, 我们通常更习惯于使用后一种形式, 因为它比前者更直观地表明了该参数是一个指针.
5. 如果将数组名传递给函数, 函数可以根据情况判定是按照数组处理还是按照指针处理, 随后根据相应地方式操作该函数, 为了直观且恰当地描述函数, 在函数中甚至可以同时使用数组和指针这两种表示方法
6. 也可以将指向子数组的起始位置的指针传递给函数, 这样, 就将数组的一部分传递给了函数
   - 例如: 如果a是一个数组, 那么下面两个函数调用 
     - f(&a[2]) 和f(a + 2) 都是将起始于a[2] 的子数组的地址传递给函数f
     - 在函数f中, 参数的声明象时可以为f(int arr[]) 或者f(int arr)
7. 如上说: 5.3 -- 2. 2. 和 6. - 数组a 可以 +2, 但是a 不可以 ++
8. p[-1] p[-2] 这样的表达式是合法的
   1. 它们分别引用位于p[0] 之前的两个元素
   2. 当然, 引用数组边界之外的对象是非法的

## 5.4 地址算术运算
1. 标准库中的提供了malloc 和 free
2. 将数组声明为static类型, 使它对外不可见
3. 一般情况下, 同其它类型的变量一样, 指针也可以初始化
4. 对指针有意义的初始化只能是0, 或者是表示其地址的表达式(见代码)
5. 指针与整数之间不能相互转换, 但 0 是唯一的例外,
   1. 常量0可以赋值给指针
   2. 0可以和指针比较
   3. 常量符号NULL定义在<stddf.h>
6. 指针可以进行比较运算
   1. 任何指针和0 的比较相等和不相等都是有意义的
   2. 但是, 指向不同数组的元素的指针之间的算术或者比较没有定义
7. 指针的减法也是有意义的
   1. 所有指针运算都会自动考虑它所指向的对象的长度
8. 有效的指针运算
   1. 相同类型指针之间的赋值
   2. 指针同整数之间的加法或减法
   3. 指向相同数组中元素的两个指针间的减法或比较运算
   4. 将指针赋值为0, 或者指针与0之间的比较
   5. 不经强制类型转换的不同类型的对象的指针的指向, 除两个指针之一是void *, 其它的都非法

## 5.5 字符指针与函数
1. 字符串常量是一个字符数组   "I am a string"
2. 字符串常量可以通过一个指向其第一个元素的指针访问
3. 字符串常量的用法
   ```c
   char *pmessage;
   pmessage = " now is the time";   // 这里跳过了&取指针的过程
   ```
4. 上面的过程并没有进行字符串的复制, 只涉及指针操作, c没有提供将整个字符串作为一个整体处理的运算符
5. 下面两个定义之间有很大的区别
   ```c
   char amessage[] = "now is the time";   // 定义一个数组
   char *pmessage = "now is the time";    // 定义一个指针
   ```
   1. amessage 是一个仅仅足以存放初始化字符串以及空字符 '\0'的一维数组, 数组中的单个字符可以进行修改, 但amessage始终指向同一个存储位置
   2. pmessage 是一个指针, 其初值指向一个字符串常量, 之后它可以修改以指向其它地址, 但如果试图修改字符串的内容, 结果是没有定义的。

6. 复制字符串的例子
7. 比较字符串的例子
8. ++ 和 -- 自增和自减
   1. *p++ = val; // 将val压入栈
      1. p 赋值后自增
   2. val = *--p; // 将栈顶元素弹出到val中
      1. p自减后的值赋值给val


## 5.6指针数组以及指向指针的指针
1. 文本行排序的例子
2. 基于第四章4.10的快排
3. 指针指向的数组名 使用 *lineptr++

## 5.7多维数组
1. 定义
   ```c
   static char daytab[2][13] = {
      {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
      {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
   }
   ```

2. 函数f的声明
   ```c
   f(int daytab[2][13]){...}
   // or
   f(int dattab[][13]){...}
   //  因为数组的行数无关紧要
   // or
   f(int (*daytab[13])){...}
   // 这种声明表明参数是一个指针, 它指向具有13个整型元素的一维数组。
   // 因为方括号[]的优先级高于*的优先级,所以要使用()
   // 如果去掉括号就变成了
   int *daytab[13]
   // 这相当于声明了一个13个元素的数组, 其中每个元素都是一个指向整型对象的指针
   ```
3. 一般来说, 除数组的第一维（下标）可以不指定外, 其余各维都必须明确指定大小

## 5.8指针数组的初始化
```c
char *month_name(int n) {
   static char *name[] = {
      "Illegal month",
      "January", "February", "March",
      "April", "May", "June",
      "October", "November", "December"
   };

   return (n < 1 || n > 12) ? name[0] : name[n];
}
```

1. 上述声明中没有指明数组name的长度, 因此, 编译器编译时将对初值个数进行统计, 并将这一准确数字填入数组的长度

## 5.9指针与多维数组
1. 初学者容易混淆二维数组与指针数组之间的区别
   ```c
      int a[10][20];
      int *b[10];
   ```
      - a是一个真正的二维数组, 它分配了200个int类型长度的存储空间
      - b该定义仅仅分配了10个指针, 并且没有对它们初始化, 它们的初始化必须以显式的方式进行
      - b的每个元素的不必都指向一个具有20个元素的向量, 某个元素可以指向具有2个元素的向量
      - 
2. 指针数组最频繁的用处是存放具有不同长度的字符串
3. page 98 图形化描述指针数组和二维数组

## 5.10命令行参数





