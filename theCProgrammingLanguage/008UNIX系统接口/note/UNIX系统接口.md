1. 本章内容包括3个主要部分：输入\输出，文件系统和存储分配

## 8.1文件描述符
1. 如果一切正常, 操作系统将像程序返回一个小的非负整数，该整数称为文件描述符
2. 任何时候对文件的输入\输出都是通过文件描述符标识文件，而不是通过文件名标识文件
3. 当命令解释器程序(shell)运行一个程序的时候, 它将打开3个文件，对应的文件描述符分别为0，1，2，依次表示标准输入，标准输出，标准错误
4. 程序的使用者可通过  <  和  >  重定向程序的 I\O

## 8.2低级I\O---read和write
```c
int n_read = read(int fd, char *buf, int n);
int n_write = write(int fd, char *buf, int n);
```
1. 这两个函数中, 第一个参数是文件描述符, 第二个参数是程序中存放读或者写的数据的字符数组, 第三个参数是要传输的字节数
   1. 读文件时，函数的返回值可能会小于请求的字节数，如果返回返回值为0，则表示到达文件的结尾
   2. 返回-1 则表示发生了某种错误
   3. 写的时候, 如果返回值与请求写入的字节数不等，则说明发生了错误

2. 在一次调用中, 读出 写入数据的字节数为任意大小, 最常用的是1(无缓冲)
3. 用更大的值调用函数可以获得更高的效率, 因为系统调用少了
4. 写一个简单的程序，将输入复制到输出
   1. 我们已经将系统调用的函数原型集中放在一个头文件syscalls.h中
   2. 该文件不是标准的
5. 用read 和 write 构造类似于getchar putchar等高级函数-版本1
   1. 读 1 个字符实现无缓冲输入
   2. c必须是一个char类型的变量，因为read函数需要一个字符指针类型的参数(&c)
   3. 将c转换为unsigned char 类型可以消除符号扩展的问题
6. 版本-2
   1. 读入一组字符，但每次只输出一个字符
   2. 如果要在包含头文件 <stdio.h> 的情况下编译这些版本的getchar函数,就有必要用 #undef预处理指令取消名字getchar的宏定义
   3. 因为在文件中，getchar是以宏方式实现的

## 8.3open, creat, close 和unlink
1. 默认除了 0 1 2 ，其它文件都必须在读或者写之前显示的打开，系统调用open和creat用于实现该功能
2. open和第七章的fopen很相似, 不同的是，前者返回一个文件描述符, 它仅仅只是一个int类型的数值，而后者返回一个文件指针
   1. 如果发生错误, open返回-1
3. 于fopen一样，参数name是一个包含文件名的字符串，第二个参数flags是一个int类型的值，它说明以何种方式打开文件
   1. O_RDONLY
   2. O_WRONLY
   3. O_RDWR
   4. 在System V UNIX系统中，这些常量在头文件<fcntl.h>中定义
   5. 在Berkeley(BSD)版版本中则在<sys/file.h>中定义
4. fd = open(name, O_RDONLY, 0)
   1. 在本章的讨论中, perms的值始终为0
5. 如果用open打开一个不存在的文件，将导致错误
   1. 可以使用creat系统调用创建新文件或者覆盖已有文件
      1. int creat(char *name, int perms);
      2. fd = creat(name, perms);
   2. 如果creat成功创建了文件, 将返回一个文件描述符，否则返回 -1
   3. 如果文件已存在, 文件长度将被截断为0
6. 如果要创建的文件不存在,则用参数perms指定权限创建文件
   1. 在UNIX文件系统中，每个文件对应一个9比特的权限信息
      1. 所有者 所有者组 其它成员
      2. 0755
         1. 所有者可以对它进行读写和执行
         2. 组和其它成员只能进行读和执行操作
7. 一个简化的UNIX程序cp来说明creat的用法
8. error函数的实现来说vfprintf
   1. vfprintf 用一个参数取代了变长参数表，此参数通过调用va_start宏进行初始化
   2. 同样vfprintf和vsprintf函数分别于fprintf 和sprintf函数类似
9. 一个程序同时打开的文件数是有限制的(通常为20), 相应的，如果一个程序需要同时处理多个文件，那么它必须重用文件描述符
10. close(int fd)
    1.  用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其它文件使用
    2.  close函数与标准库中的fcolse函数相对应，但它不需要清洗(flush)缓冲区
    3.  如果程序通过exit函数退出或从主程序退出, 所有打开的文件将关闭
11. unlink(char *name)将文件name从文件系统中删除, 它对应于标准库函数remove

## 8.4 随机访问-lseek
1. 在文件中任意移动位置而不实际读写任何数据
   1. long lseek(int fd, long offset, int origin);
      1. offset是相对于orgin指定的位置而言的，随后进行的读写操作将从此位置开始
      2. origin的值可以为0，1，2 分别指定offset
         1. 从文件开始
         2. 从当前位置
         3. 从文件结束处
   2. eg:
      1. lseek(fd, 0L, 2)
         1. 在写操作之前使用，找到文件的末尾
      2. lseek(fs, 0L, 0)
         1. 返回文件的开始处
      3. 0L也可以写成(long)0, 或仅仅写为0，但是系统调用lseek的声明必须保持一致
2. 使用lseek系统调用时, 可以将文件视为一个大数组，其代价时访问速度会慢一些，例如下面的函数将从文件的任意位置读入任意数目的字节，它将饭hi读入的字节数，若发生错误，则返回 -1

## 8.5实例-fopen函数和getc函数的实现

## 8.6实例-目录列表
## 8.7实例-存储分配程序


