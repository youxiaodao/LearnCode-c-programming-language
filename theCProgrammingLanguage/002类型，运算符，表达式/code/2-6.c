/*编写函数setbits(x, p, n, y), 该函数返回对x执行下列操作后的结果值: 
将x中从第p位开始的第n个二进制位置设置为y中最右边n位的值，x的其余为保持不变
*/

unsigned setbits(unsigned x, int p, int n, insigned y) {
    return x & ~(~(~0 << n) << (p+1-n)) |
            (y & ~(~0 << n)) << (p+1-n);
}
// 为了实现 
// xxx ... xnnnx ...xxx x
// yyy ............ynnn y
/*
1. 对x中的n位清零
    1. 把x和一个屏蔽码进行AND操作, 这个屏蔽码从位置p开始的n位是0, 其余位是1。
        1. 把一个所以位都是1的屏蔽码左移n位, 在它的最右边制造出n位0
            ~0 << n     1111 1000
        2. 把屏蔽码的最右边n位设置为1, 把其余位设置为0
            ~(~0 << n)  0000 0111
        3. 把屏蔽码最右边的n个1左移到p
            ~(~0 << n) << (p+1-n)  0001 1100   p4 n3 将字节最右边n位右移p位? 搞不懂这样的算法 但是能看的出来,移位的长度为 len_x - (p+n)
        4. 把屏蔽码从第p位开始的n位设置为0, 把其余位全部设置位1
            ~(~(~0 << n) << (p+1-n))  1110 0011
        4. 屏蔽码和x进行AND操作
            x & ~(~0 << n) << (p+1-n)
2. 把y中除n位 以外 都清零, 并左移到第p处
    用最右端的n位全为1, 其余全为0的屏蔽码进行AND操作
        1. ~(~0<<n) 000 0111
        2. 和y进行  AND ,就选出了y最右端的n位
            y &  ~(~0<<n) 
        3. 把n位移到p处
            (y &  ~(~0<<n)) << (p+1-n)
        4. 最后进行or操作
            x & ~(~(~0 << n) << (p+1-n)) | (y & ~(~0 << n)) << (p+1-n);
3. 对前两步的结果进行or操作
 xxx ... x000x ...xxx x
 000 ....0nnn0....000 y
 ----->
 xxx.....xnnnx....xxx x
*/
//  1111 1111 1111 1000

//http://www.learntosolveit.com/cprogramming/Ex_2.6_setbits.html  发现一个好站