# 2.1变量名
# 2.2数据类型及长度
1. short 类型通常是16位，long通常为32位
2. 类型限定符signed与unsigned可用于限定char类型或任何整型
3. unsigned 类型的数总是正值或0，并遵循算术模2^n定律,其中n是该类型占用的位数
4. unsigned char 0~255
5. signed char -128 ~ 127
6. 不限定的char对象是否带符号取决于具体机器，但可打印字符总是正值
7. 二进制补码，按位取反，位移操作
# 2.3常量
1. l L long
2. u U 无符号常量
3. ul unsigned long
4. 带前缀0的整型常量 表示八进制
5. 前缀0x 0X 为16进制
6. 后缀L也可以表示long 
7. 字符常量 'x' 
8. '0' --> ASCii编码48 它和0没有关系
9. 某些字符可以通过转义序列符来表示  /n
10. 表示任意字节的位模式:
    1. \000 000代表1~3个八进制数字(0-7)
    2. \xhh hh是一个或多个十六进制数字(0~9, a~f, A~F)

        ```c
            #define VTAB '\013'     /*ASCII 纵向制表符*/
            #define BELL '\007'     /*ASCII 响铃符*/
            // 或者
            #define VTAB '\0b'     /*ASCII 纵向制表符*/
            #define BELL '\07'     /*ASCII 响铃符*/
        ```
11. 字符常量'\0'表示值为0的字符, 也就是空字符(null)
12. 常量表达式时仅仅包含常量的表达式，这种表达式在编译时求值，而不在运行时求值，它可以出现在常量可以出现的任何位置
    ```c
        #define MAXLINE 1000
        char line[MAXLINE];
        // 或
        #define LEAP 1  /* 闰年 */
        int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31]
    ```
        
13. C语言对字符串的长度没有限制，但程序必须扫描完整个字符转后才能确定字符串的长度
14. strlen(s) 可以返回字符串s的长度，但长度不包括末尾的'\0'
15. 'x' 和 'X'时不同的， 前者时一个整数，其值是字母x在机器字符集中对应的数值(内部表示值); 后者是一个包含一个字符(X)以及一个结束符'\0'的字符数组
16. 枚举常量: 枚举是一个常量整型值的列表
17. 在没有显示说明的情况下, enum类型中第一个枚举名的值为0, 第二个为1， 以此类推。如果只制定了部分枚举名的值, 那么未指定值的将依着最后一个指定值向后递增
    ```c
    enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t', NEWLINE = '\n', VTAB = '\v', RETURN = '\r' }
    //或者
    enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC}
    ```
18. 相对于#define语句来说, 它的优势在于常量值可以自动生成。
19. 尽管可以声明enum类型的变量，但是编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。

# 2.4声明
1. 默认情况下, 外部变量与静态变量将被初始化为0, 未经显示初始化的自动变量的值为未定义值(即无效值)。
2. const 限定符指定数组所有元素的值都不能被修改
3. const 限定符也配合数组参数使用, 它表明函数不能修改数组元素的值:
    ```c
    const char msg[] = "warning";
    ```
4. 如果试图修改const限定符限定的值，其结果取决于具体的实现
# 2.5算术运算符
1. + - * / % 整数除法会截断结果中的小数部分。
2. 取模运算符%不能应用于float或者double类型。
3. 在有负操作符的情况下，整数除法截取方向以及取模运算结果的符号取决于具体的机器实现，这和处理上溢或下溢的情况是一样的。
4. 二元运算符 + - 比 * / 的优先级低，比一元运算符 + — 的优先级低
# 2.6关系运算符于逻辑运算符
1. > >= < <= 它们具有相同的优先级, 优先级仅次与他们的是相等性运算符: == !=
2. 关系运算符的优先级比算术运算符的低。因此, 表达式 i < lim - 1 等价于 i< (lim - 1)
3. 逻辑运算符&&的优先级比||的优先级高, 但是两者都比关系运算符和相等性运算符的优先级低。
4. 关系为真, 表达式的结果为数值1; 如果为假, 结果为0;
5. 逻辑非运算符 ! 
6. (!valid) 和 (valid == 0) 很难判定哪一种好, 前一种用法读法更直观，但是对一些复杂的结构可能会难以理解

# 2.7类型转换
1. 一般来说, 自动转换是指把 比较窄 的操作数转换为 比较宽 的操作数, 并且不丢失信息的转换
2. 针对可能导致信息丢失的表达式, 编译器可能会给出警告
3. char 类型就是较小的整型
4. atoi
5. tolower
6. isdigit
7. C没有指定char类型的变量是signed还是unsigned.当把一个char类型转换为int类型。
    1. 对于不同的机器， 结果不同
    2. 
8. 为了保证程序的可移植性， 如果要在char类型中存储非字符数据， 最好指定signed 和 unsigned
9. 转换规则 A.6
10. 表达式中包含unsigned 类型的操作数时, 转换规则要复杂一些 
    1. 取决于机器中不同整数类型的大小
    2. int 16位 long 32位 -1L > 1U

11. 强制类型转换
    1. (类型名)表达式
    2. double sqrt(double); 函数调用 root2 = sqrt(2); 不需要使用强制类型转换, 就可以自动将整数2强制转换为double类型的值2.0
    3. srand和rand
# 2.8自增与自减运算符
1. 表达式++n先将n的值递增1, 然后再使用变量n的值.
2. 表达式n++则是先使用n的值, 再将n的值递增1.
3. 也就是说, ++n和n++的效果是不同的.

# 2.9位运算符
1. C提供了6个位操作运算符
2. 只能作用于整型操作数, 即只能作用于带符号或者无符号的char, short, int, long类型
    1. & 按位与(AND)
    2. | 按位或(OR)
    3. ^ 按位异或 (相同则0, 不同则1)
    4. >> 左移
    5. << 右移
    6. ~ 按位求反

3. 注意区分 & 和&&
    1. x = 1;y = 2; x&y = 0
    2. x << 2 等同与 x * 4
4. 算术移位和逻辑移位
5. 
# 2.10赋值运算符与表达式
1. i = i+1 ===> i+=1
2. x >>= 1
# 2.11条件表达式
0. expr1 ? expr2 : expr3
1. 三元运算符 a > b ? a : b

    ```c
    if(a>b)
        z = a;
    else:
        z = b;

    z = (a>b) ? a:b  /* z = max(a,b) */
    ```
2. 如果1 和 2 的类型不同，结果将由转换规则决定
    1. (n > 0) ? f : n  表达式是 float类型, 和n是否为正值无关
3. ?: 的优先级非常低, 仅高于赋运算符
4. 建议使用圆括号, 易读
# 2.12运算符优先级与求值次序
1. C语言没有指定同一运算符中多个操作符的计算顺序(&& ||)
2. 没有指定函数各参数的求值顺序, 在不同的编译器中可能产生不同的结果
    ```c
    printf("%d %d \n", ++n, power(2,n));  /*错*/
    //改为
    ++n;
    printf("%d %d \n", n, power(2,n)); 
    ```
3. 函数调用， 嵌套赋值语句，自增减 都有可能产生"副作用"---在对表达式求值的同时, 修改了某些变量的值
    1. a[i] = i++;
        问题是: 数组下标引用新值还是旧值? 编译器的解释可能不同
        标准中未具体规定
4. 在任何一种编程语言中，如果代码的执行结果与求值顺序有关，都是不好的设计风格
5. 有必要了解哪些问题需要避免，但是不知道问题再各种机器上是如何解决的，就最好不要尝试某种特殊的实现方式
